(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6574],{57694:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return T}});var l=t(52322),r=t(45392),o=t(96835),a=t(49857),c=t(73645),i=t(70758),s=t(2784),u=(0,s.createContext)(),p=function(e,n,t){return e[n+8*t]},f=function(e,n,t,l){if(0!==p(e,t,l))return[];var r=[],o=[],a=function(t,l){var a=p(e,t,l);return 0!==a&&(a!==n?(o.push(t+8*l),!0):a!==n||(r.push.apply(r,o),!1))};o.length=0;for(var c=t-1;c>=0&&!1!==a(c,l);c--);o.length=0;for(var i=t+1;i<8&&!1!==a(i,l);i++);o.length=0;for(var s=l-1;s>=0&&!1!==a(t,s);s--);o.length=0;for(var u=l+1;u<8&&!1!==a(t,u);u++);o.length=0;for(var f=t-1,d=l-1;f>=0&&d>=0&&!1!==a(f,d);f--,d--);o.length=0;for(var h=t+1,m=l-1;h<8&&m>=0&&!1!==a(h,m);h++,m--);o.length=0;for(var E=t+1,C=l+1;E<8&&C<8&&!1!==a(E,C);E++,C++);o.length=0;for(var g=t-1,x=l+1;g>=0&&x<8&&!1!==a(g,x);g--,x++);return r},d=function(e,n){for(var t=[],l=0;l<64;l++)f(e,n,l%8,Math.floor(l/8)).length>0&&t.push(l);return t};function h(e){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function m(e,n,t){var l;return(l=function(e,n){if("object"!==h(e)||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var l=t.call(e,n||"default");if("object"!==h(l))return l;throw TypeError("@@toPrimitive must return a primitive value.")}return("string"===n?String:Number)(e)}(n,"string"),(n="symbol"===h(l)?l:String(l))in e)?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var E=function(e){var n=e.value,t=m(m({},1,"black:primary"),2,"white:primary");return s.createElement(a.Z,{sx:{borderRadius:"50%",backgroundColor:t[n],height:"100%",width:"100%"}})},C=["piece","canPlacePiece","turn"];function g(){return(g=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}var x=function(e){var n=e.piece,t=e.canPlacePiece,l=e.turn,r=function(e,n){if(null==e)return{};var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)t=o[l],!(n.indexOf(t)>=0)&&Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}(e,C);return t?s.createElement(a.Z,g({sx:{p:"1x",cursor:"pointer",opacity:.1,_hover:{opacity:1}}},r),s.createElement(E,{value:l})):s.createElement(a.Z,g({sx:{p:"1x"}},r),s.createElement(E,{value:n}))};function v(){return(v=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}function b(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var y=function(e){var n=(0,s.useContext)(u),t=n.restart,l=n.cells,r=n.updateCells,o=n.turn,p=n.nextTurn,h=1===o?2:1,m=d(l,o),E=d(l,h),C=0===m.length&&0===E.length;return s.createElement(a.Z,v({sx:{width:"80vw",height:"80vw",maxWidth:480,maxHeight:480,backgroundImage:"linear-gradient(90deg, rgba(0, 0, 0, 0.5) 2.5%, transparent 2.5%), linear-gradient( rgba(0, 0, 0, 0.95) 2.5%, transparent 2.5%)",backgroundSize:"12.5% 12.5%",backgroundRepeat:"repeat",backgroundColor:"wheat",display:"grid",gridTemplateColumns:"repeat(8, 12.5%)",gridTemplateRows:"repeat(8, 12.5%)",position:"relative"}},e),C&&s.createElement(s.Fragment,null,s.createElement(a.Z,{sx:{position:"absolute",inset:0,backgroundColor:"black:primary",opacity:.7}}),s.createElement(c.Z,{sx:{position:"absolute",inset:0,alignItems:"center",justifyContent:"center",userSelect:"none",cursor:"pointer"},onClick:function(){t()}},s.createElement(i.Z,{color:"white:primary",fontSize:48,lineHeight:"1"},"GAME OVER"))),l.map(function(e,n){var t=n%8,a=Math.floor(n/8),c=!C&&1===o&&m.includes(n);return s.createElement(x,{key:"".concat(t,"-").concat(a),"data-coordinate-x":t,"data-coordinate-y":a,piece:e,canPlacePiece:c,turn:o,onClick:function(e){if(c){var i=function(e){if(Array.isArray(e))return b(e)}(l)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(l)||function(e,n){if(e){if("string"==typeof e)return b(e,void 0);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return b(e,void 0)}}(l)||function(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),s=f(l,o,t,a);if(s.length>0){i[n]=o;for(var u=0;u<s.length;++u)i[s[u]]=o;r(i),p()}}}})}))},I=function(){var e=Array(64).fill(1),n=function(e,n){return e+8*n};e[n(0,0)]=90,e[n(7,0)]=90,e[n(0,7)]=90,e[n(7,7)]=90;for(var t=2;t<6;++t)e[n(t,0)]=10,e[n(t,7)]=10;for(var l=2;l<6;++l)e[n(0,l)]=10,e[n(7,l)]=10;return e[n(0,1)]=-20,e[n(1,0)]=-20,e[n(1,1)]=-20,e[n(6,0)]=-20,e[n(6,1)]=-20,e[n(7,1)]=-20,e[n(0,6)]=-20,e[n(1,6)]=-20,e[n(1,7)]=-20,e[n(6,6)]=-20,e[n(7,6)]=-20,e[n(6,7)]=-20,e}(),P=function(e){var n=d(e,1),t=d(e,2);if(0===n.length&&0===t.length)return(e.filter(function(e){return 1===e}).length-e.filter(function(e){return 2===e}).length)*1e4;for(var l=0,r=0,o=0;o<e.length;++o)2===e[o]&&(r+=I[o]),1===e[o]&&(l+=I[o]);return l-r+(n.length-t.length)},S=function e(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=1===t?2:1,c=!!(l%2),i=c?-1/0:1/0,s=d(n,t);if(0===s.length)return 0===d(n,a).length?P(n):e(n,a,l+1,r,o);if(l>r)return P(n);for(var u=-1,p=0;p<s.length;p++){var h=s[p],m=f(n,t,h%8,Math.floor(h/8));if(0!==m.length){n[h]=t;for(var E=0;E<m.length;E++)n[m[E]]=t;var C=e(n,a,l+1,r,i);n[h]=0;for(var g=0;g<m.length;g++)n[m[g]]=a;if(null!==o&&c&&C>=o||null!==o&&!c&&C<=o)return C;c?i=Math.max(i,C):(0===l&&C<i&&(u=h),i=Math.min(i,C))}}return 0===l?u:i};function _(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var l,r,o,a,c=[],i=!0,s=!1;try{if(o=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;i=!1}else for(;!(i=(l=o.call(t)).done)&&(c.push(l.value),c.length!==n);i=!0);}catch(e){s=!0,r=e}finally{try{if(!i&&null!=t.return&&(a=t.return(),Object(a)!==a))return}finally{if(s)throw r}}return c}}(e,n)||A(e,n)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function A(e,n){if(e){if("string"==typeof e)return B(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return B(e,n)}}function B(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var O=function(){var e=_((0,s.useState)(1),2),n=e[0],t=e[1],l=_((0,s.useState)(Array(64).fill(0)),2),r=l[0],o=l[1],p=function(){return t(2===n?1:2)},d=(0,s.useCallback)(function(){var e=Array(64).fill(0);e[27]=2,e[28]=1,e[35]=1,e[36]=2,o(e),t(1)},[]),h=(0,s.useMemo)(function(){return{cells:r,updateCells:o,turn:n,nextTurn:p,restart:d}},[r,o,n,p,d]);return(0,s.useEffect)(function(){d()},[d]),(0,s.useEffect)(function(){2===n&&requestAnimationFrame(function(){var e=function(e){if(Array.isArray(e))return B(e)}(r)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(r)||A(r)||function(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),t=S(e,n),l=f(r,n,t%8,Math.floor(t/8));if(l.length>0){e[t]=n;for(var a=0;a<l.length;++a)e[l[a]]=n;o(e),p()}})},[n,p,r,o]),s.createElement(u.Provider,{value:h},s.createElement(a.Z,{sx:{width:"80vw",maxWidth:480,mb:"4x"}},s.createElement(c.Z,{alignItems:"center",justifyContent:"space-between"},s.createElement(i.Z,{fontSize:"xl",lineHeight:"xl"},"White: ",r.reduce(function(e,n){return 2===n?e+1:e},0)),s.createElement(i.Z,{fontSize:"xl",lineHeight:"xl"},"Black: ",r.reduce(function(e,n){return 1===n?e+1:e},0)))),s.createElement(y,null))};function Z(e){var n=Object.assign({div:"div",h1:"h1"},(0,r.ah)(),e.components);return(0,l.jsxs)(n.div,{className:"main-content",id:"main-content",children:["\n","\n",(0,l.jsx)(n.h1,{id:"othello",children:"Othello"}),"\n",(0,l.jsx)(o.Z,Object.assign({},{component:O,file:{data:"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from './constants';\nimport {\n  GameStateContext,\n} from './context';\nimport {\n  getReversiblePieces,\n} from './utils';\nimport Board from './Board';\nimport { search } from './computer';\n\nconst Othello = () => {\n  const [turn, setTurn] = useState(BLACK_PIECE);\n  const [cells, updateCells] = useState((new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE));\n  const nextTurn = () => setTurn(turn === WHITE_PIECE ? BLACK_PIECE : WHITE_PIECE);\n  const restart = useCallback(() => {\n    const nextCells = (new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE);\n    nextCells[BOARD_SIZE * 3 + 3] = WHITE_PIECE;\n    nextCells[BOARD_SIZE * 3 + 4] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 3] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 4] = WHITE_PIECE;\n    updateCells(nextCells);\n    setTurn(BLACK_PIECE);\n  }, []);\n  const context = useMemo(() => ({\n    cells,\n    updateCells,\n    turn,\n    nextTurn,\n    restart,\n  }), [cells, updateCells, turn, nextTurn, restart]);\n\n  // Game Start\n  useEffect(() => {\n    restart();\n  }, [restart]);\n\n  // Computer Move\n  useEffect(() => {\n    if (turn !== WHITE_PIECE) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      const nextCells = [...cells];\n      const cellId = search(nextCells, turn);\n      const x = cellId % 8;\n      const y = Math.floor(cellId / 8);\n      const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n      if (reversiblePieces.length > 0) {\n        nextCells[cellId] = turn;\n        for (let i = 0; i < reversiblePieces.length; ++i) {\n          nextCells[reversiblePieces[i]] = turn;\n        }\n        updateCells(nextCells);\n        nextTurn();\n      }\n    });\n  }, [turn, nextTurn, cells, updateCells]);\n\n  return (\n    <GameStateContext.Provider value={context}>\n      <Box\n        sx={{\n          width: '80vw',\n          maxWidth: BOARD_SIZE * CELL_SIZE,\n          mb: '4x',\n        }}\n      >\n        <Flex alignItems=\"center\" justifyContent=\"space-between\">\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            White: {cells.reduce((acc, piece) => piece === WHITE_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            Black: {cells.reduce((acc, piece) => piece === BLACK_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n        </Flex>\n      </Box>\n      <Board />\n    </GameStateContext.Provider>\n  );\n};\n\nexport default Othello;",path:"pages/playground/othello/index.page.mdx"},sandbox:{files:{"src/pages/playground/othello/othello/constants.js":"export const BOARD_SIZE = 8;\nexport const CELL_SIZE = 60;\nexport const EMPTY_PIECE = 0;\nexport const BLACK_PIECE = 1;\nexport const WHITE_PIECE = 2;","src/pages/playground/othello/othello/context.js":"import { createContext, useContext } from 'react';\n\nconst GameStateContext = createContext();\n\nconst useGameState = () => {\n  const context = useContext(GameStateContext);\n  return context;\n};\n\nexport {\n  GameStateContext,\n  useGameState,\n};","src/pages/playground/othello/othello/utils.js":"import { BOARD_SIZE, EMPTY_PIECE } from '@/pages/playground/othello/othello/constants';\n\nexport const getPiece = (cells, x, y) => cells[x + BOARD_SIZE * y];\n\nexport const getReversiblePieces = (cells, turn, x, y) => {\n  const piece = getPiece(cells, x, y);\n  if (piece !== EMPTY_PIECE) {\n    return [];\n  }\n\n  const reversiblePieces = [];\n  const opponentPieces = [];\n  const checkCell = (x, y) => {\n    const piece = getPiece(cells, x, y);\n    if (piece === EMPTY_PIECE) {\n      return false;\n    }\n    if (piece !== turn) {\n      opponentPieces.push(x + BOARD_SIZE * y);\n      return true;\n    }\n    if (piece === turn) {\n      reversiblePieces.push(...opponentPieces);\n      return false;\n    }\n    return true;\n  };\n\n  // to left\n  opponentPieces.length = 0;\n  for (let i = x - 1; i >= 0; i--) {\n    if (checkCell(i, y) === false) {\n      break;\n    }\n  }\n\n  // to right\n  opponentPieces.length = 0;\n  for (let i = x + 1; i < 8; i++) {\n    if (checkCell(i, y) === false) {\n      break;\n    }\n  }\n\n  // to top\n  opponentPieces.length = 0;\n  for (let i = y - 1; i >= 0; i--) {\n    if (checkCell(x, i) === false) {\n      break;\n    }\n  }\n\n  // to bottom\n  opponentPieces.length = 0;\n  for (let i = y + 1; i < 8; i++) {\n    if (checkCell(x, i) === false) {\n      break;\n    }\n  }\n\n  // to upper left\n  opponentPieces.length = 0;\n  for (let i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to upper right\n  opponentPieces.length = 0;\n  for (let i = x + 1, j = y - 1; i < 8 && j >= 0; i++, j--) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to bottom right\n  opponentPieces.length = 0;\n  for (let i = x + 1, j = y + 1; i < 8 && j < 8; i++, j++) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to bottom left\n  opponentPieces.length = 0;\n  for (let i = x - 1, j = y + 1; i >= 0 && j < 8; i--, j++) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  return reversiblePieces;\n};\n\nexport const getPlaceableCells = (cells, turn) => {\n  const placeableCells = [];\n  for (let i = 0; i < BOARD_SIZE**2; i++) {\n    const x = i % BOARD_SIZE;\n    const y = Math.floor(i / BOARD_SIZE);\n    const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n    if (reversiblePieces.length > 0) {\n      placeableCells.push(i);\n    }\n  }\n  return placeableCells;\n};","src/pages/playground/othello/othello/Board.js":"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport Cell from '@/pages/playground/othello/othello/Cell';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport { \n  useGameState,\n} from '@/pages/playground/othello/othello/context';\nimport {\n  getReversiblePieces,\n  getPlaceableCells,\n} from '@/pages/playground/othello/othello/utils';\n\nconst Board = (props) => {\n  const { restart, cells, updateCells, turn, nextTurn } = useGameState();\n  const opponent = turn === BLACK_PIECE ? WHITE_PIECE : BLACK_PIECE;\n  const placeableCells = getPlaceableCells(cells, turn);\n  const opponentPlaceableCells = getPlaceableCells(cells, opponent);\n  const isGameEnd = placeableCells.length === 0 && opponentPlaceableCells.length === 0;\n\n  return (\n    <Box\n      sx={{\n        width: '80vw',\n        height: '80vw',\n        maxWidth: BOARD_SIZE * CELL_SIZE,\n        maxHeight: BOARD_SIZE * CELL_SIZE,\n        backgroundImage: 'linear-gradient(90deg, rgba(0, 0, 0, 0.5) 2.5%, transparent 2.5%), linear-gradient( rgba(0, 0, 0, 0.95) 2.5%, transparent 2.5%)',\n        backgroundSize: '12.5% 12.5%',\n        backgroundRepeat: 'repeat',\n        backgroundColor: 'wheat',\n        display: 'grid',\n        gridTemplateColumns: 'repeat(8, 12.5%)',\n        gridTemplateRows: 'repeat(8, 12.5%)',\n        position: 'relative',\n      }}\n      {...props}\n    >\n      {isGameEnd && (\n        <>\n          <Box\n            sx={{\n              position: 'absolute',\n              inset: 0,\n              backgroundColor: 'black:primary',\n              opacity: 0.7,\n            }}\n          />\n          <Flex\n            sx={{\n              position: 'absolute',\n              inset: 0,\n              alignItems: 'center',\n              justifyContent: 'center',\n              userSelect: 'none',\n              cursor: 'pointer',\n            }}\n            onClick={() => {\n              restart();\n            }}\n          >\n            <Text\n              color=\"white:primary\"\n              fontSize={48}\n              lineHeight=\"1\"\n            >\n              GAME OVER\n            </Text>\n          </Flex>\n        </>\n      )}\n      {cells.map((piece, cellId) => {\n        const x = cellId % BOARD_SIZE;\n        const y = Math.floor(cellId / BOARD_SIZE);\n        const canPlacePiece = !isGameEnd && (turn === BLACK_PIECE) && placeableCells.includes(cellId);\n        const handleClick = (e) => {\n          if (!canPlacePiece) {\n            return;\n          }\n          const nextCells = [...cells];\n          const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n          if (reversiblePieces.length > 0) {\n            nextCells[cellId] = turn;\n            for (let i = 0; i < reversiblePieces.length; ++i) {\n              nextCells[reversiblePieces[i]] = turn;\n            }\n            updateCells(nextCells);\n            nextTurn();\n          }\n        };\n\n        return (\n          <Cell\n            key={`${x}-${y}`}\n            data-coordinate-x={x}\n            data-coordinate-y={y}\n            piece={piece}\n            canPlacePiece={canPlacePiece}\n            turn={turn}\n            onClick={handleClick}\n          />\n        );\n      })}\n    </Box>\n  );\n};\n\nexport default Board;","src/pages/playground/othello/othello/Cell.js":"import {\n  Box,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport Piece from '@/pages/playground/othello/othello/Piece';\n\nconst Cell = ({\n  piece,\n  canPlacePiece,\n  turn,\n  ...rest\n}) => {\n  if (canPlacePiece) {\n    return (\n      <Box\n        sx={{\n          p: '1x',\n          cursor: 'pointer',\n          opacity: 0.1,\n          _hover: {\n            opacity: 1,\n          }\n        }}\n        {...rest}\n      >\n        <Piece value={turn} />\n      </Box>\n    );\n  }\n\n  return (\n    <Box\n      sx={{\n        p: '1x',\n      }}\n      {...rest}\n    >\n      <Piece value={piece} />\n    </Box>\n  );\n};\n\nexport default Cell;","src/pages/playground/othello/othello/Piece.js":"import {\n  Box,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport { BLACK_PIECE, WHITE_PIECE } from '@/pages/playground/othello/othello/constants';\n\nconst Piece = ({ value }) => {\n  const backgroundColorMap = {\n    [BLACK_PIECE]: 'black:primary',\n    [WHITE_PIECE]: 'white:primary',\n  };\n\n  return (\n    <Box\n      sx={{\n        borderRadius: '50%',\n        backgroundColor: backgroundColorMap[value],\n        height: '100%',\n        width: '100%',\n      }}\n    />\n  );\n};\n\nexport default Piece;","src/pages/playground/othello/othello/computer.js":"import {\n  BOARD_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport {\n  getReversiblePieces,\n  getPlaceableCells,\n} from '@/pages/playground/othello/othello/utils';\n\nconst MAX_DEPTH = 4;\n\nconst evaluationTable = (() => {\n  const cells = (new Array(BOARD_SIZE**2)).fill(1);\n  const toCellId = (x, y) => x + BOARD_SIZE * y;\n\n  // Four corners\n  cells[toCellId(0, 0)] = 90;\n  cells[toCellId(BOARD_SIZE - 1, 0)] = 90;\n  cells[toCellId(0, BOARD_SIZE - 1)] = 90;\n  cells[toCellId(BOARD_SIZE - 1, BOARD_SIZE - 1)] = 90;\n\n  // Four edges, excluding adjacent corners\n  for (let x = 2; x < BOARD_SIZE - 2; ++x) {\n    cells[toCellId(x, 0)] = 10;\n    cells[toCellId(x, BOARD_SIZE - 1)] = 10;\n  }\n  for (let y = 2; y < BOARD_SIZE - 2; ++y) {\n    cells[toCellId(0, y)] = 10;\n    cells[toCellId(BOARD_SIZE - 1, y)] = 10;\n  }\n\n  // Adjacent corners: top-left\n  cells[toCellId(0, 1)] = -20;\n  cells[toCellId(1, 0)] = -20;\n  cells[toCellId(1, 1)] = -20;\n  // Adjacent corners: top-right\n  cells[toCellId(BOARD_SIZE - 2, 0)] = -20;\n  cells[toCellId(BOARD_SIZE - 2, 1)] = -20;\n  cells[toCellId(BOARD_SIZE - 1, 1)] = -20;\n  // Adjacent corners: bottom-left\n  cells[toCellId(0, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(1, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(1, BOARD_SIZE - 1)] = -20;\n  // Adjacent corners: bottom-right\n  cells[toCellId(BOARD_SIZE - 2, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(BOARD_SIZE - 1, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(BOARD_SIZE - 2, BOARD_SIZE - 1)] = -20;\n\n  /*\n  for (let i = 0; i < BOARD_SIZE; ++i) {\n    console.log('##', cells.slice(BOARD_SIZE * i, BOARD_SIZE * i + BOARD_SIZE));\n  }\n  */\n\n  return cells;\n})();\n\nconst evaluate = (cells) => {\n  const p1 = getPlaceableCells(cells, BLACK_PIECE);\n  const p2 = getPlaceableCells(cells, WHITE_PIECE);\n\n  if (p1.length === 0 && p2.length === 0) {\n    // Game End\n    const blackPieces = cells.filter(cell => cell === BLACK_PIECE).length;\n    const whitePieces = cells.filter(cell => cell === WHITE_PIECE).length;\n    return (blackPieces - whitePieces) * 10000;\n  }\n\n  let blackScore = 0;\n  let whiteScore = 0;\n  for (let i = 0; i < cells.length; ++i) {\n    if (cells[i] === WHITE_PIECE) {\n      whiteScore += evaluationTable[i];\n    }\n    if (cells[i] === BLACK_PIECE) {\n      blackScore += evaluationTable[i];\n    }\n  }\n\n  // Maximum mobility\n  const mobility = p1.length - p2.length;\n\n  const score = (blackScore - whiteScore) + mobility;\n  return score;\n};\n\n// https://github.com/Jhhhha/Game-Tree\n//\n// function alphabeta(node, depth, α, β, MinMax) \n//   if depth = 0 or node is left_node\n//     return benefit of node\n//\n//   if MinMax = Max\n//     v := -∞\n//     foreach child of node\n//       v := max(v, alphabeta(child, depth - 1, α, β, FALSE)) \n//       α := max(α, v)\n//       if β ≤ α\n//         break\n//     return v\n//   else\n//     v := ∞\n//     foreach child of node\n//       v := min(v, alphabeta(child, depth - 1, α, β, TRUE))\n//       β := min(β, v)\n//       if β ≤ α\n//         break\n//     return v\nconst search = (cells, turn = WHITE_PIECE, depth = 0, maxDepth = MAX_DEPTH, alphaBeta = null) => {\n  const opponentTurn = (turn === BLACK_PIECE) ? WHITE_PIECE : BLACK_PIECE;\n  const isOddDepth = !!(depth % 2); // Search for maximum value if it's an odd-depth\n  let value = isOddDepth ? -Infinity : Infinity;\n  const placeableCells = getPlaceableCells(cells, turn);\n\n  if (placeableCells.length === 0) { // No placeable cells\n    if (getPlaceableCells(cells, opponentTurn).length === 0) {\n      // Game End\n      return evaluate(cells);\n    }\n    return search(cells, opponentTurn, depth + 1, maxDepth, alphaBeta);\n  }\n\n  if (depth > maxDepth) {\n    // Reached the maximum depth\n    return evaluate(cells);\n  }\n\n  let computedCellId = -1;\n\n  for (let i = 0; i < placeableCells.length; i++) {\n    const cellId = placeableCells[i];\n    const x = cellId % 8;\n    const y = Math.floor(cellId / 8);\n    const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n    if (reversiblePieces.length === 0) {\n      continue;\n    }\n\n    cells[cellId] = turn;\n    for (let i = 0; i < reversiblePieces.length; i++) {\n      cells[reversiblePieces[i]] = turn;\n    }\n\n    const vv = search(cells, opponentTurn, depth + 1, maxDepth, value);\n\n    cells[cellId] = EMPTY_PIECE;\n    for (let i = 0; i < reversiblePieces.length; i++) {\n      cells[reversiblePieces[i]] = opponentTurn;\n    }\n\n    // Find the maximum value for the odd-depth\n    if (alphaBeta !== null && isOddDepth && vv >= alphaBeta) {\n      // No need to search if the maximum value is already greater than the minimum value of the previous depth\n      return vv;\n    }\n\n    // Find the minimum value for the even-depth\n    if (alphaBeta !== null && !isOddDepth && vv <= alphaBeta) {\n      // No need to search if the minimum value is already smaller than the maximum value of the previous depth\n      return vv;\n    }\n\n    if (isOddDepth) {\n      value = Math.max(value, vv);\n    } else {\n      if (depth === 0 && vv < value) {\n        computedCellId = cellId;\n      }\n      value = Math.min(value, vv);\n    }\n  }\n\n  if (depth === 0) {\n    return computedCellId;\n  }\n\n  return value;\n};\n\nexport {\n  search,\n};"},raw:"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport {\n  GameStateContext,\n} from '@/pages/playground/othello/othello/context';\nimport {\n  getReversiblePieces,\n} from '@/pages/playground/othello/othello/utils';\nimport Board from '@/pages/playground/othello/othello/Board';\nimport { search } from '@/pages/playground/othello/othello/computer';\n\nconst Othello = () => {\n  const [turn, setTurn] = useState(BLACK_PIECE);\n  const [cells, updateCells] = useState((new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE));\n  const nextTurn = () => setTurn(turn === WHITE_PIECE ? BLACK_PIECE : WHITE_PIECE);\n  const restart = useCallback(() => {\n    const nextCells = (new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE);\n    nextCells[BOARD_SIZE * 3 + 3] = WHITE_PIECE;\n    nextCells[BOARD_SIZE * 3 + 4] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 3] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 4] = WHITE_PIECE;\n    updateCells(nextCells);\n    setTurn(BLACK_PIECE);\n  }, []);\n  const context = useMemo(() => ({\n    cells,\n    updateCells,\n    turn,\n    nextTurn,\n    restart,\n  }), [cells, updateCells, turn, nextTurn, restart]);\n\n  // Game Start\n  useEffect(() => {\n    restart();\n  }, [restart]);\n\n  // Computer Move\n  useEffect(() => {\n    if (turn !== WHITE_PIECE) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      const nextCells = [...cells];\n      const cellId = search(nextCells, turn);\n      const x = cellId % 8;\n      const y = Math.floor(cellId / 8);\n      const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n      if (reversiblePieces.length > 0) {\n        nextCells[cellId] = turn;\n        for (let i = 0; i < reversiblePieces.length; ++i) {\n          nextCells[reversiblePieces[i]] = turn;\n        }\n        updateCells(nextCells);\n        nextTurn();\n      }\n    });\n  }, [turn, nextTurn, cells, updateCells]);\n\n  return (\n    <GameStateContext.Provider value={context}>\n      <Box\n        sx={{\n          width: '80vw',\n          maxWidth: BOARD_SIZE * CELL_SIZE,\n          mb: '4x',\n        }}\n      >\n        <Flex alignItems=\"center\" justifyContent=\"space-between\">\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            White: {cells.reduce((acc, piece) => piece === WHITE_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            Black: {cells.reduce((acc, piece) => piece === BLACK_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n        </Flex>\n      </Box>\n      <Board />\n    </GameStateContext.Provider>\n  );\n};\n\nexport default Othello;",title:"Tonic UI"}}))]})}var T=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,r.ah)(),e.components).wrapper;return n?(0,l.jsx)(n,Object.assign({},e,{children:(0,l.jsx)(Z,e)})):Z(e)}},96835:function(e,n,t){"use strict";t.d(n,{Z:function(){return O}});var l=t(27216),r=t(40596),o=t(49857),a=t(73645),c=t(99870),i=t(62272),s=t(14594),u=t(65019),p=t(37384),f=t(99554),d=t(69111),h=t(5632),m=t(2784),E=t(65245);function C(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var g=function(e){var n=document.createElement("textarea");n.value=e,n.setAttribute("readonly",""),n.style.position="absolute",n.style.left="-9999px",document.body.appendChild(n);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);n.select(),document.execCommand("copy"),document.body.removeChild(n),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))},x=function(e){var n,t=function(e){if(Array.isArray(e))return e}(n=(0,m.useState)(!1))||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var l,r,o,a,c=[],i=!0,s=!1;try{for(o=(t=t.call(e)).next;!(i=(l=o.call(t)).done)&&(c.push(l.value),2!==c.length);i=!0);}catch(e){s=!0,r=e}finally{try{if(!i&&null!=t.return&&(a=t.return(),Object(a)!==a))return}finally{if(s)throw r}}return c}}(n,2)||function(e,n){if(e){if("string"==typeof e)return C(e,2);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return C(e,2)}}(n,2)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),l=t[0],r=t[1];return{value:e,onCopy:function(){g(e),r(!0),setTimeout(function(){return r(!1)},1500)},hasCopied:l}},v=t(63768),b=t(76761),y=t(73205),I=t(98107),P=t(44285),S=["component","defaultExpanded","expanded","file","sandbox"];function _(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var l,r,o,a,c=[],i=!0,s=!1;try{if(o=(t=t.call(e)).next,0===n){if(Object(t)!==t)return;i=!1}else for(;!(i=(l=o.call(t)).done)&&(c.push(l.value),c.length!==n);i=!0);}catch(e){s=!0,r=e}finally{try{if(!i&&null!=t.return&&(a=t.return(),Object(a)!==a))return}finally{if(s)throw r}}return c}}(e,n)||function(e,n){if(e){if("string"==typeof e)return A(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return A(e,n)}}(e,n)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function A(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var B=function(e){var n,t=e.component,C=e.defaultExpanded,g=e.expanded,A=e.file,B=e.sandbox;!function(e,n){if(null!=e){var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)t=o[l],!(n.indexOf(t)>=0)&&Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}}}(e,S);var O=(0,h.useRouter)(),Z=_((0,m.useReducer)(function(e){return!e},!1),2),T=Z[0],R=Z[1],k=(0,l.u)(),j=_((0,r.Z)(),1)[0],D={dark:b.y,light:b.q}[j],w=_((0,u.Z)(null!=g?g:void 0!==C&&C),2),M=w[0],L=w[1],H=x(null==A?void 0:A.data),W=H.onCopy,K=H.hasCopied,G=(0,m.useCallback)(function(){W()},[W]),F=(0,m.useCallback)(function(){(0,y.b)(B)},[B]),z=(0,m.useCallback)(function(){R(),L(!1)},[R,L]);return((0,m.useEffect)(function(){void 0!==g&&g!==M&&L(g)},[g,M,L]),t)?m.createElement(E.nu,{code:null==A?void 0:A.data,disabled:!0,language:"jsx",theme:D},m.createElement(o.Z,{border:1,borderColor:{dark:"gray:70",light:"gray:30"}[j],p:"4x"},m.createElement(o.Z,{fontSize:"sm",lineHeight:"sm"},m.createElement(m.Fragment,{key:T},m.createElement(t,null)))),m.createElement(a.Z,{columnGap:"2x",justifyContent:"flex-end",mb:"4x"},m.createElement(P.Z,{"data-track":M?"CodeBlock|hide_source|".concat((0,I.Z)({path:O.pathname})):"CodeBlock|show_source|".concat((0,I.Z)({path:O.pathname})),onClick:L},m.createElement(c.Z,{label:M?"Hide the source":"Show the source"},m.createElement(p.Z,null))),m.createElement(P.Z,{"data-track":"CodeBlock|copy_source|".concat((0,I.Z)({path:O.pathname})),onClick:G},m.createElement(c.Z,{label:K?"Copied":"Copy the source"},m.createElement(f.Z,null))),m.createElement(P.Z,{"data-track":"CodeBlock|edit_in_codesandbox|".concat(O.pathname),onClick:F},m.createElement(c.Z,{label:"Edit in CodeSandbox"},m.createElement(v.Z,null))),m.createElement(P.Z,{"data-track":"CodeBlock|reset|".concat(O.pathname),onClick:z},m.createElement(c.Z,{label:"Reset the demo"},m.createElement(d.Z,null)))),m.createElement(i.Z,{in:M},m.createElement(s.Z,{in:M,unmountOnExit:!0},m.createElement(o.Z,{as:E.uz,sx:{fontFamily:"mono",fontSize:"md",lineHeight:"md",mb:"4x","& > .prism-code":{padding:"".concat(null==k?void 0:null===(n=k.space)||void 0===n?void 0:n["4x"]," !important"),overflowX:"auto"}}})))):m.createElement(E.nu,{code:null==A?void 0:A.data,disabled:!0,language:"jsx",theme:D},m.createElement(o.Z,{as:E.uz,sx:{fontFamily:"mono",fontSize:"sm","& > .prism-code":{overflowX:"auto"}}}))};B.displayName="Demo";var O=B},34418:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/playground/othello",function(){return t(57694)}])},99554:function(e,n,t){"use strict";t.d(n,{Z:function(){return o}}),t(2784);var l=t(75928),r=t(52903),o=(0,l.Z)((0,r.tZ)("path",{d:"M12 0h-6c-0.5 0-1 0.5-1 1v3h-3c-0.5 0-1 0.5-1 1v10c0 0.5 0.5 1 1 1h8c0.5 0 1-0.5 1-1v-3h3c0.5 0 1-0.5 1-1v-8l-3-3zM12 1.4l1.6 1.6h-1.6v-1.6zM10 15h-8v-10h5v3h3v7zM8 7v-1.6l1.6 1.6h-1.6zM14 11h-3v-4l-3-3h-2v-3h5v3h3v7z"}),"FileCopyOIcon")},69111:function(e,n,t){"use strict";t.d(n,{Z:function(){return o}}),t(2784);var l=t(75928),r=t(52903),o=(0,l.Z)((0,r.tZ)("path",{d:"M10 7l1.995-1.995c-0.921-1.215-2.365-1.992-3.99-1.992-2.758 0-4.993 2.235-4.993 4.993s2.235 4.993 4.993 4.993c1.839 0 3.446-0.995 4.313-2.475l0.013-0.024 1.732 1c-1.233 2.111-3.487 3.507-6.068 3.507-3.867 0-7.003-3.135-7.003-7.003s3.135-7.003 7.003-7.003c2.183 0 4.133 0.999 5.417 2.565l0.010 0.012 1.579-1.579v5z"}),"RedoIcon")}},function(e){e.O(0,[2888,9774,179],function(){return e(e.s=34418)}),_N_E=e.O()}]);