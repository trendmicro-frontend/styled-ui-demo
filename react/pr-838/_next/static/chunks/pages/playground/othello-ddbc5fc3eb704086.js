(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6574],{55272:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return index_page}});var l=t(52322),r=t(45392),o=t(83449),a=t(67569),c=t(2784),i=(0,c.createContext)(),getPiece=function(e,n,t){return e[n+8*t]},getReversiblePieces=function(e,n,t,l){if(0!==getPiece(e,t,l))return[];var r=[],o=[],checkCell=function(t,l){var a=getPiece(e,t,l);return 0!==a&&(a!==n?(o.push(t+8*l),!0):a!==n||(r.push.apply(r,o),!1))};o.length=0;for(var a=t-1;a>=0&&!1!==checkCell(a,l);a--);o.length=0;for(var c=t+1;c<8&&!1!==checkCell(c,l);c++);o.length=0;for(var i=l-1;i>=0&&!1!==checkCell(t,i);i--);o.length=0;for(var s=l+1;s<8&&!1!==checkCell(t,s);s++);o.length=0;for(var u=t-1,p=l-1;u>=0&&p>=0&&!1!==checkCell(u,p);u--,p--);o.length=0;for(var d=t+1,h=l-1;d<8&&h>=0&&!1!==checkCell(d,h);d++,h--);o.length=0;for(var f=t+1,C=l+1;f<8&&C<8&&!1!==checkCell(f,C);f++,C++);o.length=0;for(var E=t-1,m=l+1;E>=0&&m<8&&!1!==checkCell(E,m);E--,m++);return r},getPlaceableCells=function(e,n){for(var t=[],l=0;l<64;l++)getReversiblePieces(e,n,l%8,Math.floor(l/8)).length>0&&t.push(l);return t};function _defineProperty(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var othello_Piece=function(e){var n=e.value,t=_defineProperty(_defineProperty({},1,"black:primary"),2,"white:primary");return c.createElement(a.Box,{sx:{borderRadius:"50%",backgroundColor:t[n],height:"100%",width:"100%"}})},s=["piece","canPlacePiece","turn"];function _extends(){return(_extends=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}var othello_Cell=function(e){var n=e.piece,t=e.canPlacePiece,l=e.turn,r=function(e,n){if(null==e)return{};var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)t=o[l],!(n.indexOf(t)>=0)&&Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}(e,s);return t?c.createElement(a.Box,_extends({sx:{p:"1x",cursor:"pointer",opacity:.1,_hover:{opacity:1}}},r),c.createElement(othello_Piece,{value:l})):c.createElement(a.Box,_extends({sx:{p:"1x"}},r),c.createElement(othello_Piece,{value:n}))};function Board_extends(){return(Board_extends=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var othello_Board=function(e){var n=(0,c.useContext)(i),t=n.restart,l=n.cells,r=n.updateCells,o=n.turn,s=n.nextTurn,u=1===o?2:1,p=getPlaceableCells(l,o),d=getPlaceableCells(l,u),h=0===p.length&&0===d.length;return c.createElement(a.Box,Board_extends({sx:{width:"80vw",height:"80vw",maxWidth:480,maxHeight:480,backgroundImage:"linear-gradient(90deg, rgba(0, 0, 0, 0.5) 2.5%, transparent 2.5%), linear-gradient( rgba(0, 0, 0, 0.95) 2.5%, transparent 2.5%)",backgroundSize:"12.5% 12.5%",backgroundRepeat:"repeat",backgroundColor:"wheat",display:"grid",gridTemplateColumns:"repeat(8, 12.5%)",gridTemplateRows:"repeat(8, 12.5%)",position:"relative"}},e),h&&c.createElement(c.Fragment,null,c.createElement(a.Box,{sx:{position:"absolute",inset:0,backgroundColor:"black:primary",opacity:.7}}),c.createElement(a.Flex,{sx:{position:"absolute",inset:0,alignItems:"center",justifyContent:"center",userSelect:"none",cursor:"pointer"},onClick:function(){t()}},c.createElement(a.Text,{color:"white:primary",fontSize:48,lineHeight:"1"},"GAME OVER"))),l.map(function(e,n){var t=n%8,a=Math.floor(n/8),i=!h&&1===o&&p.includes(n);return c.createElement(othello_Cell,{key:"".concat(t,"-").concat(a),"data-coordinate-x":t,"data-coordinate-y":a,piece:e,canPlacePiece:i,turn:o,onClick:function(e){if(i){var c=function(e){if(Array.isArray(e))return _arrayLikeToArray(e)}(l)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(l)||function(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return _arrayLikeToArray(e,n)}}(l)||function(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),u=getReversiblePieces(l,o,t,a);if(u.length>0){c[n]=o;for(var p=0;p<u.length;++p)c[u[p]]=o;r(c),s()}}}})}))},u=function(){var e=Array(64).fill(1),toCellId=function(e,n){return e+8*n};e[toCellId(0,0)]=90,e[toCellId(7,0)]=90,e[toCellId(0,7)]=90,e[toCellId(7,7)]=90;for(var n=2;n<6;++n)e[toCellId(n,0)]=10,e[toCellId(n,7)]=10;for(var t=2;t<6;++t)e[toCellId(0,t)]=10,e[toCellId(7,t)]=10;return e[toCellId(0,1)]=-20,e[toCellId(1,0)]=-20,e[toCellId(1,1)]=-20,e[toCellId(6,0)]=-20,e[toCellId(6,1)]=-20,e[toCellId(7,1)]=-20,e[toCellId(0,6)]=-20,e[toCellId(1,6)]=-20,e[toCellId(1,7)]=-20,e[toCellId(6,6)]=-20,e[toCellId(7,6)]=-20,e[toCellId(6,7)]=-20,e}(),evaluate=function(e){var n=getPlaceableCells(e,1),t=getPlaceableCells(e,2);if(0===n.length&&0===t.length)return(e.filter(function(e){return 1===e}).length-e.filter(function(e){return 2===e}).length)*1e4;for(var l=0,r=0,o=0;o<e.length;++o)2===e[o]&&(r+=u[o]),1===e[o]&&(l+=u[o]);return l-r+(n.length-t.length)},search=function search(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=1===n?2:1,a=!!(t%2),c=a?-1/0:1/0,i=getPlaceableCells(e,n);if(0===i.length)return 0===getPlaceableCells(e,o).length?evaluate(e):search(e,o,t+1,l,r);if(t>l)return evaluate(e);for(var s=-1,u=0;u<i.length;u++){var p=i[u],d=getReversiblePieces(e,n,p%8,Math.floor(p/8));if(0!==d.length){e[p]=n;for(var h=0;h<d.length;h++)e[d[h]]=n;var f=search(e,o,t+1,l,c);e[p]=0;for(var C=0;C<d.length;C++)e[d[C]]=o;if(null!==r&&a&&f>=r||null!==r&&!a&&f<=r)return f;a?c=Math.max(c,f):(0===t&&f<c&&(s=p),c=Math.min(c,f))}}return 0===t?s:c};function _slicedToArray(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t,l,r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var o=[],a=!0,c=!1;try{for(r=r.call(e);!(a=(t=r.next()).done)&&(o.push(t.value),!n||o.length!==n);a=!0);}catch(e){c=!0,l=e}finally{try{a||null==r.return||r.return()}finally{if(c)throw l}}return o}}(e,n)||othello_unsupportedIterableToArray(e,n)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function othello_unsupportedIterableToArray(e,n){if(e){if("string"==typeof e)return othello_arrayLikeToArray(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return othello_arrayLikeToArray(e,n)}}function othello_arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var othello=function(){var e=_slicedToArray((0,c.useState)(1),2),n=e[0],t=e[1],l=_slicedToArray((0,c.useState)(Array(64).fill(0)),2),r=l[0],o=l[1],nextTurn=function(){return t(2===n?1:2)},s=(0,c.useCallback)(function(){var e=Array(64).fill(0);e[27]=2,e[28]=1,e[35]=1,e[36]=2,o(e),t(1)},[]),u=(0,c.useMemo)(function(){return{cells:r,updateCells:o,turn:n,nextTurn:nextTurn,restart:s}},[r,o,n,nextTurn,s]);return(0,c.useEffect)(function(){s()},[s]),(0,c.useEffect)(function(){2===n&&requestAnimationFrame(function(){var e=function(e){if(Array.isArray(e))return othello_arrayLikeToArray(e)}(r)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(r)||othello_unsupportedIterableToArray(r)||function(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),t=search(e,n),l=getReversiblePieces(r,n,t%8,Math.floor(t/8));if(l.length>0){e[t]=n;for(var a=0;a<l.length;++a)e[l[a]]=n;o(e),nextTurn()}})},[n,nextTurn,r,o]),c.createElement(i.Provider,{value:u},c.createElement(a.Box,{sx:{width:"80vw",maxWidth:480,mb:"4x"}},c.createElement(a.Flex,{alignItems:"center",justifyContent:"space-between"},c.createElement(a.Text,{fontSize:"xl",lineHeight:"xl"},"White: ",r.reduce(function(e,n){return 2===n?e+1:e},0)),c.createElement(a.Text,{fontSize:"xl",lineHeight:"xl"},"Black: ",r.reduce(function(e,n){return 1===n?e+1:e},0)))),c.createElement(othello_Board,null))};function _createMdxContent(e){var n=Object.assign({div:"div",h1:"h1"},(0,r.ah)(),e.components);return(0,l.jsxs)(n.div,{className:"main-content",id:"main-content",children:["\n","\n",(0,l.jsx)(n.h1,{id:"othello",children:"Othello"}),"\n",(0,l.jsx)(o.Z,{component:othello,file:{data:"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from './constants';\nimport {\n  GameStateContext,\n} from './context';\nimport {\n  getReversiblePieces,\n} from './utils';\nimport Board from './Board';\nimport { search } from './computer';\n\nconst Othello = () => {\n  const [turn, setTurn] = useState(BLACK_PIECE);\n  const [cells, updateCells] = useState((new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE));\n  const nextTurn = () => setTurn(turn === WHITE_PIECE ? BLACK_PIECE : WHITE_PIECE);\n  const restart = useCallback(() => {\n    const nextCells = (new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE);\n    nextCells[BOARD_SIZE * 3 + 3] = WHITE_PIECE;\n    nextCells[BOARD_SIZE * 3 + 4] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 3] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 4] = WHITE_PIECE;\n    updateCells(nextCells);\n    setTurn(BLACK_PIECE);\n  }, []);\n  const context = useMemo(() => ({\n    cells,\n    updateCells,\n    turn,\n    nextTurn,\n    restart,\n  }), [cells, updateCells, turn, nextTurn, restart]);\n\n  // Game Start\n  useEffect(() => {\n    restart();\n  }, [restart]);\n\n  // Computer Move\n  useEffect(() => {\n    if (turn !== WHITE_PIECE) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      const nextCells = [...cells];\n      const cellId = search(nextCells, turn);\n      const x = cellId % 8;\n      const y = Math.floor(cellId / 8);\n      const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n      if (reversiblePieces.length > 0) {\n        nextCells[cellId] = turn;\n        for (let i = 0; i < reversiblePieces.length; ++i) {\n          nextCells[reversiblePieces[i]] = turn;\n        }\n        updateCells(nextCells);\n        nextTurn();\n      }\n    });\n  }, [turn, nextTurn, cells, updateCells]);\n\n  return (\n    <GameStateContext.Provider value={context}>\n      <Box\n        sx={{\n          width: '80vw',\n          maxWidth: BOARD_SIZE * CELL_SIZE,\n          mb: '4x',\n        }}\n      >\n        <Flex alignItems=\"center\" justifyContent=\"space-between\">\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            White: {cells.reduce((acc, piece) => piece === WHITE_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            Black: {cells.reduce((acc, piece) => piece === BLACK_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n        </Flex>\n      </Box>\n      <Board />\n    </GameStateContext.Provider>\n  );\n};\n\nexport default Othello;",path:"pages/playground/othello/index.page.mdx"},sandbox:{files:{"src/pages/playground/othello/othello/constants.js":"export const BOARD_SIZE = 8;\nexport const CELL_SIZE = 60;\nexport const EMPTY_PIECE = 0;\nexport const BLACK_PIECE = 1;\nexport const WHITE_PIECE = 2;","src/pages/playground/othello/othello/context.js":"import { createContext, useContext } from 'react';\n\nconst GameStateContext = createContext();\n\nconst useGameState = () => {\n  const context = useContext(GameStateContext);\n  return context;\n};\n\nexport {\n  GameStateContext,\n  useGameState,\n};","src/pages/playground/othello/othello/utils.js":"import { BOARD_SIZE, EMPTY_PIECE } from '@/pages/playground/othello/othello/constants';\n\nexport const getPiece = (cells, x, y) => cells[x + BOARD_SIZE * y];\n\nexport const getReversiblePieces = (cells, turn, x, y) => {\n  const piece = getPiece(cells, x, y);\n  if (piece !== EMPTY_PIECE) {\n    return [];\n  }\n\n  const reversiblePieces = [];\n  const opponentPieces = [];\n  const checkCell = (x, y) => {\n    const piece = getPiece(cells, x, y);\n    if (piece === EMPTY_PIECE) {\n      return false;\n    }\n    if (piece !== turn) {\n      opponentPieces.push(x + BOARD_SIZE * y);\n      return true;\n    }\n    if (piece === turn) {\n      reversiblePieces.push(...opponentPieces);\n      return false;\n    }\n    return true;\n  };\n\n  // to left\n  opponentPieces.length = 0;\n  for (let i = x - 1; i >= 0; i--) {\n    if (checkCell(i, y) === false) {\n      break;\n    }\n  }\n\n  // to right\n  opponentPieces.length = 0;\n  for (let i = x + 1; i < 8; i++) {\n    if (checkCell(i, y) === false) {\n      break;\n    }\n  }\n\n  // to top\n  opponentPieces.length = 0;\n  for (let i = y - 1; i >= 0; i--) {\n    if (checkCell(x, i) === false) {\n      break;\n    }\n  }\n\n  // to bottom\n  opponentPieces.length = 0;\n  for (let i = y + 1; i < 8; i++) {\n    if (checkCell(x, i) === false) {\n      break;\n    }\n  }\n\n  // to upper left\n  opponentPieces.length = 0;\n  for (let i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to upper right\n  opponentPieces.length = 0;\n  for (let i = x + 1, j = y - 1; i < 8 && j >= 0; i++, j--) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to bottom right\n  opponentPieces.length = 0;\n  for (let i = x + 1, j = y + 1; i < 8 && j < 8; i++, j++) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  // to bottom left\n  opponentPieces.length = 0;\n  for (let i = x - 1, j = y + 1; i >= 0 && j < 8; i--, j++) {\n    if (checkCell(i, j) === false) {\n      break;\n    }\n  }\n\n  return reversiblePieces;\n};\n\nexport const getPlaceableCells = (cells, turn) => {\n  const placeableCells = [];\n  for (let i = 0; i < BOARD_SIZE**2; i++) {\n    const x = i % BOARD_SIZE;\n    const y = Math.floor(i / BOARD_SIZE);\n    const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n    if (reversiblePieces.length > 0) {\n      placeableCells.push(i);\n    }\n  }\n  return placeableCells;\n};","src/pages/playground/othello/othello/Board.js":"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport Cell from '@/pages/playground/othello/othello/Cell';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport { \n  useGameState,\n} from '@/pages/playground/othello/othello/context';\nimport {\n  getReversiblePieces,\n  getPlaceableCells,\n} from '@/pages/playground/othello/othello/utils';\n\nconst Board = (props) => {\n  const { restart, cells, updateCells, turn, nextTurn } = useGameState();\n  const opponent = turn === BLACK_PIECE ? WHITE_PIECE : BLACK_PIECE;\n  const placeableCells = getPlaceableCells(cells, turn);\n  const opponentPlaceableCells = getPlaceableCells(cells, opponent);\n  const isGameEnd = placeableCells.length === 0 && opponentPlaceableCells.length === 0;\n\n  return (\n    <Box\n      sx={{\n        width: '80vw',\n        height: '80vw',\n        maxWidth: BOARD_SIZE * CELL_SIZE,\n        maxHeight: BOARD_SIZE * CELL_SIZE,\n        backgroundImage: 'linear-gradient(90deg, rgba(0, 0, 0, 0.5) 2.5%, transparent 2.5%), linear-gradient( rgba(0, 0, 0, 0.95) 2.5%, transparent 2.5%)',\n        backgroundSize: '12.5% 12.5%',\n        backgroundRepeat: 'repeat',\n        backgroundColor: 'wheat',\n        display: 'grid',\n        gridTemplateColumns: 'repeat(8, 12.5%)',\n        gridTemplateRows: 'repeat(8, 12.5%)',\n        position: 'relative',\n      }}\n      {...props}\n    >\n      {isGameEnd && (\n        <>\n          <Box\n            sx={{\n              position: 'absolute',\n              inset: 0,\n              backgroundColor: 'black:primary',\n              opacity: 0.7,\n            }}\n          />\n          <Flex\n            sx={{\n              position: 'absolute',\n              inset: 0,\n              alignItems: 'center',\n              justifyContent: 'center',\n              userSelect: 'none',\n              cursor: 'pointer',\n            }}\n            onClick={() => {\n              restart();\n            }}\n          >\n            <Text\n              color=\"white:primary\"\n              fontSize={48}\n              lineHeight=\"1\"\n            >\n              GAME OVER\n            </Text>\n          </Flex>\n        </>\n      )}\n      {cells.map((piece, cellId) => {\n        const x = cellId % BOARD_SIZE;\n        const y = Math.floor(cellId / BOARD_SIZE);\n        const canPlacePiece = !isGameEnd && (turn === BLACK_PIECE) && placeableCells.includes(cellId);\n        const handleClick = (e) => {\n          if (!canPlacePiece) {\n            return;\n          }\n          const nextCells = [...cells];\n          const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n          if (reversiblePieces.length > 0) {\n            nextCells[cellId] = turn;\n            for (let i = 0; i < reversiblePieces.length; ++i) {\n              nextCells[reversiblePieces[i]] = turn;\n            }\n            updateCells(nextCells);\n            nextTurn();\n          }\n        };\n\n        return (\n          <Cell\n            key={`${x}-${y}`}\n            data-coordinate-x={x}\n            data-coordinate-y={y}\n            piece={piece}\n            canPlacePiece={canPlacePiece}\n            turn={turn}\n            onClick={handleClick}\n          />\n        );\n      })}\n    </Box>\n  );\n};\n\nexport default Board;","src/pages/playground/othello/othello/Cell.js":"import {\n  Box,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport Piece from '@/pages/playground/othello/othello/Piece';\n\nconst Cell = ({\n  piece,\n  canPlacePiece,\n  turn,\n  ...rest\n}) => {\n  if (canPlacePiece) {\n    return (\n      <Box\n        sx={{\n          p: '1x',\n          cursor: 'pointer',\n          opacity: 0.1,\n          _hover: {\n            opacity: 1,\n          }\n        }}\n        {...rest}\n      >\n        <Piece value={turn} />\n      </Box>\n    );\n  }\n\n  return (\n    <Box\n      sx={{\n        p: '1x',\n      }}\n      {...rest}\n    >\n      <Piece value={piece} />\n    </Box>\n  );\n};\n\nexport default Cell;","src/pages/playground/othello/othello/Piece.js":"import {\n  Box,\n} from '@tonic-ui/react';\nimport React from 'react';\nimport { BLACK_PIECE, WHITE_PIECE } from '@/pages/playground/othello/othello/constants';\n\nconst Piece = ({ value }) => {\n  const backgroundColorMap = {\n    [BLACK_PIECE]: 'black:primary',\n    [WHITE_PIECE]: 'white:primary',\n  };\n\n  return (\n    <Box\n      sx={{\n        borderRadius: '50%',\n        backgroundColor: backgroundColorMap[value],\n        height: '100%',\n        width: '100%',\n      }}\n    />\n  );\n};\n\nexport default Piece;","src/pages/playground/othello/othello/computer.js":"import {\n  BOARD_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport {\n  getReversiblePieces,\n  getPlaceableCells,\n} from '@/pages/playground/othello/othello/utils';\n\nconst MAX_DEPTH = 4;\n\nconst evaluationTable = (() => {\n  const cells = (new Array(BOARD_SIZE**2)).fill(1);\n  const toCellId = (x, y) => x + BOARD_SIZE * y;\n\n  // Four corners\n  cells[toCellId(0, 0)] = 90;\n  cells[toCellId(BOARD_SIZE - 1, 0)] = 90;\n  cells[toCellId(0, BOARD_SIZE - 1)] = 90;\n  cells[toCellId(BOARD_SIZE - 1, BOARD_SIZE - 1)] = 90;\n\n  // Four edges, excluding adjacent corners\n  for (let x = 2; x < BOARD_SIZE - 2; ++x) {\n    cells[toCellId(x, 0)] = 10;\n    cells[toCellId(x, BOARD_SIZE - 1)] = 10;\n  }\n  for (let y = 2; y < BOARD_SIZE - 2; ++y) {\n    cells[toCellId(0, y)] = 10;\n    cells[toCellId(BOARD_SIZE - 1, y)] = 10;\n  }\n\n  // Adjacent corners: top-left\n  cells[toCellId(0, 1)] = -20;\n  cells[toCellId(1, 0)] = -20;\n  cells[toCellId(1, 1)] = -20;\n  // Adjacent corners: top-right\n  cells[toCellId(BOARD_SIZE - 2, 0)] = -20;\n  cells[toCellId(BOARD_SIZE - 2, 1)] = -20;\n  cells[toCellId(BOARD_SIZE - 1, 1)] = -20;\n  // Adjacent corners: bottom-left\n  cells[toCellId(0, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(1, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(1, BOARD_SIZE - 1)] = -20;\n  // Adjacent corners: bottom-right\n  cells[toCellId(BOARD_SIZE - 2, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(BOARD_SIZE - 1, BOARD_SIZE - 2)] = -20;\n  cells[toCellId(BOARD_SIZE - 2, BOARD_SIZE - 1)] = -20;\n\n  /*\n  for (let i = 0; i < BOARD_SIZE; ++i) {\n    console.log('##', cells.slice(BOARD_SIZE * i, BOARD_SIZE * i + BOARD_SIZE));\n  }\n  */\n\n  return cells;\n})();\n\nconst evaluate = (cells) => {\n  const p1 = getPlaceableCells(cells, BLACK_PIECE);\n  const p2 = getPlaceableCells(cells, WHITE_PIECE);\n\n  if (p1.length === 0 && p2.length === 0) {\n    // Game End\n    const blackPieces = cells.filter(cell => cell === BLACK_PIECE).length;\n    const whitePieces = cells.filter(cell => cell === WHITE_PIECE).length;\n    return (blackPieces - whitePieces) * 10000;\n  }\n\n  let blackScore = 0;\n  let whiteScore = 0;\n  for (let i = 0; i < cells.length; ++i) {\n    if (cells[i] === WHITE_PIECE) {\n      whiteScore += evaluationTable[i];\n    }\n    if (cells[i] === BLACK_PIECE) {\n      blackScore += evaluationTable[i];\n    }\n  }\n\n  // Maximum mobility\n  const mobility = p1.length - p2.length;\n\n  const score = (blackScore - whiteScore) + mobility;\n  return score;\n};\n\n// https://github.com/Jhhhha/Game-Tree\n//\n// function alphabeta(node, depth, α, β, MinMax) \n//   if depth = 0 or node is left_node\n//     return benefit of node\n//\n//   if MinMax = Max\n//     v := -∞\n//     foreach child of node\n//       v := max(v, alphabeta(child, depth - 1, α, β, FALSE)) \n//       α := max(α, v)\n//       if β ≤ α\n//         break\n//     return v\n//   else\n//     v := ∞\n//     foreach child of node\n//       v := min(v, alphabeta(child, depth - 1, α, β, TRUE))\n//       β := min(β, v)\n//       if β ≤ α\n//         break\n//     return v\nconst search = (cells, turn = WHITE_PIECE, depth = 0, maxDepth = MAX_DEPTH, alphaBeta = null) => {\n  const opponentTurn = (turn === BLACK_PIECE) ? WHITE_PIECE : BLACK_PIECE;\n  const isOddDepth = !!(depth % 2); // Search for maximum value if it's an odd-depth\n  let value = isOddDepth ? -Infinity : Infinity;\n  const placeableCells = getPlaceableCells(cells, turn);\n\n  if (placeableCells.length === 0) { // No placeable cells\n    if (getPlaceableCells(cells, opponentTurn).length === 0) {\n      // Game End\n      return evaluate(cells);\n    }\n    return search(cells, opponentTurn, depth + 1, maxDepth, alphaBeta);\n  }\n\n  if (depth > maxDepth) {\n    // Reached the maximum depth\n    return evaluate(cells);\n  }\n\n  let computedCellId = -1;\n\n  for (let i = 0; i < placeableCells.length; i++) {\n    const cellId = placeableCells[i];\n    const x = cellId % 8;\n    const y = Math.floor(cellId / 8);\n    const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n    if (reversiblePieces.length === 0) {\n      continue;\n    }\n\n    cells[cellId] = turn;\n    for (let i = 0; i < reversiblePieces.length; i++) {\n      cells[reversiblePieces[i]] = turn;\n    }\n\n    const vv = search(cells, opponentTurn, depth + 1, maxDepth, value);\n\n    cells[cellId] = EMPTY_PIECE;\n    for (let i = 0; i < reversiblePieces.length; i++) {\n      cells[reversiblePieces[i]] = opponentTurn;\n    }\n\n    // Find the maximum value for the odd-depth\n    if (alphaBeta !== null && isOddDepth && vv >= alphaBeta) {\n      // No need to search if the maximum value is already greater than the minimum value of the previous depth\n      return vv;\n    }\n\n    // Find the minimum value for the even-depth\n    if (alphaBeta !== null && !isOddDepth && vv <= alphaBeta) {\n      // No need to search if the minimum value is already smaller than the maximum value of the previous depth\n      return vv;\n    }\n\n    if (isOddDepth) {\n      value = Math.max(value, vv);\n    } else {\n      if (depth === 0 && vv < value) {\n        computedCellId = cellId;\n      }\n      value = Math.min(value, vv);\n    }\n  }\n\n  if (depth === 0) {\n    return computedCellId;\n  }\n\n  return value;\n};\n\nexport {\n  search,\n};"},raw:"import {\n  Box,\n  Flex,\n  Text,\n} from '@tonic-ui/react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  BOARD_SIZE,\n  CELL_SIZE,\n  EMPTY_PIECE,\n  BLACK_PIECE,\n  WHITE_PIECE,\n} from '@/pages/playground/othello/othello/constants';\nimport {\n  GameStateContext,\n} from '@/pages/playground/othello/othello/context';\nimport {\n  getReversiblePieces,\n} from '@/pages/playground/othello/othello/utils';\nimport Board from '@/pages/playground/othello/othello/Board';\nimport { search } from '@/pages/playground/othello/othello/computer';\n\nconst Othello = () => {\n  const [turn, setTurn] = useState(BLACK_PIECE);\n  const [cells, updateCells] = useState((new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE));\n  const nextTurn = () => setTurn(turn === WHITE_PIECE ? BLACK_PIECE : WHITE_PIECE);\n  const restart = useCallback(() => {\n    const nextCells = (new Array(BOARD_SIZE**2)).fill(EMPTY_PIECE);\n    nextCells[BOARD_SIZE * 3 + 3] = WHITE_PIECE;\n    nextCells[BOARD_SIZE * 3 + 4] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 3] = BLACK_PIECE;\n    nextCells[BOARD_SIZE * 4 + 4] = WHITE_PIECE;\n    updateCells(nextCells);\n    setTurn(BLACK_PIECE);\n  }, []);\n  const context = useMemo(() => ({\n    cells,\n    updateCells,\n    turn,\n    nextTurn,\n    restart,\n  }), [cells, updateCells, turn, nextTurn, restart]);\n\n  // Game Start\n  useEffect(() => {\n    restart();\n  }, [restart]);\n\n  // Computer Move\n  useEffect(() => {\n    if (turn !== WHITE_PIECE) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      const nextCells = [...cells];\n      const cellId = search(nextCells, turn);\n      const x = cellId % 8;\n      const y = Math.floor(cellId / 8);\n      const reversiblePieces = getReversiblePieces(cells, turn, x, y);\n      if (reversiblePieces.length > 0) {\n        nextCells[cellId] = turn;\n        for (let i = 0; i < reversiblePieces.length; ++i) {\n          nextCells[reversiblePieces[i]] = turn;\n        }\n        updateCells(nextCells);\n        nextTurn();\n      }\n    });\n  }, [turn, nextTurn, cells, updateCells]);\n\n  return (\n    <GameStateContext.Provider value={context}>\n      <Box\n        sx={{\n          width: '80vw',\n          maxWidth: BOARD_SIZE * CELL_SIZE,\n          mb: '4x',\n        }}\n      >\n        <Flex alignItems=\"center\" justifyContent=\"space-between\">\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            White: {cells.reduce((acc, piece) => piece === WHITE_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n          <Text fontSize=\"xl\" lineHeight=\"xl\">\n            Black: {cells.reduce((acc, piece) => piece === BLACK_PIECE ? acc + 1 : acc, 0)}\n          </Text>\n        </Flex>\n      </Box>\n      <Board />\n    </GameStateContext.Provider>\n  );\n};\n\nexport default Othello;",title:"Tonic UI"}})]})}var index_page=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,r.ah)(),e.components).wrapper;return n?(0,l.jsx)(n,Object.assign({},e,{children:(0,l.jsx)(_createMdxContent,e)})):_createMdxContent(e)}},83449:function(e,n,t){"use strict";t.d(n,{Z:function(){return E}});var l=t(67569),r=t(49427),o=t(5632),a=t(2784),c=t(65245),i=t(82821),s=t(90622),u=t(52057),p=t(63651),d=["size"];function _extends(){return(_extends=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}var h=(0,a.forwardRef)(function(e,n){var t=e.size,r=function(e,n){if(null==e)return{};var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)t=o[l],!(n.indexOf(t)>=0)&&Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}(e,d);return a.createElement(l.SVGIcon,_extends({size:t,viewBox:"0 0 1024 1024"},r),a.createElement("path",{d:"M755 140.3l0.5-0.3h0.3L512 0 268.3 140h-0.3l0.8 0.4L68.6 256v512L512 1024l443.4-256V256L755 140.3z m-30 506.4v171.2L548 920.1V534.7L883.4 341v215.7l-158.4 90z m-584.4-90.6V340.8L476 534.4v385.7L300 818.5V646.7l-159.4-90.6zM511.7 280l171.1-98.3 166.3 96-336.9 194.5-337-194.6 165.7-95.7L511.7 280z"}))});h.displayName="CodeSandboxIcon";var f=t(94981);function _slicedToArray(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t,l,r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var o=[],a=!0,c=!1;try{for(r=r.call(e);!(a=(t=r.next()).done)&&(o.push(t.value),!n||o.length!==n);a=!0);}catch(e){c=!0,l=e}finally{try{a||null==r.return||r.return()}finally{if(c)throw l}}return o}}(e,n)||function(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);if("Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return _arrayLikeToArray(e,n)}}(e,n)||function(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,l=Array(n);t<n;t++)l[t]=e[t];return l}var C={fontFamily:'"SFMono-Medium", "SF Mono", "Segoe UI Mono", Menlo, Consolas, Courier, monospace',fontSize:14,overflowX:"auto"},Demo=function(e){var n=e.component,t=e.file,d=e.sandbox,E=(0,o.useRouter)(),m=_slicedToArray((0,a.useReducer)(function(e){return!e},!1),2),x=m[0],g=m[1],I=_slicedToArray((0,l.useColorMode)(),1)[0],y={dark:s.y,light:s.q}[I],b=_slicedToArray((0,r.useToggle)(!1),2),v=b[0],P=b[1],_=(0,i.Z)(null==t?void 0:t.data),A=_.onCopy,S=_.hasCopied,B=(0,a.useCallback)(function(){A()},[A]),T=(0,a.useCallback)(function(){(0,u.b)(d)},[d]),O=(0,a.useCallback)(function(){g(),P(!1)},[g,P]);return a.createElement(c.nu,{code:null==t?void 0:t.data,disabled:!0,language:"jsx",theme:y},a.createElement(l.Box,{border:1,borderColor:{dark:"gray:70",light:"gray:30"}[I],p:"4x"},a.createElement(l.Box,{fontSize:"sm",lineHeight:"sm"},a.createElement(a.Fragment,{key:x},a.createElement(n,null)))),a.createElement(l.Flex,{columnGap:"2x",justifyContent:"flex-end",mb:"4x"},a.createElement(f.Z,{"data-track":v?"CodeBlock|hide_source|".concat((0,p.Z)({path:E.pathname})):"CodeBlock|show_source|".concat((0,p.Z)({path:E.pathname})),onClick:P},a.createElement(l.Tooltip,{label:v?"Hide the source":"Show the source"},a.createElement(l.Icon,{icon:"code",size:{sm:"5x",md:"4x"}}))),a.createElement(f.Z,{"data-track":"CodeBlock|copy_source|".concat((0,p.Z)({path:E.pathname})),onClick:B},a.createElement(l.Tooltip,{label:S?"Copied":"Copy the source"},a.createElement(l.Icon,{icon:"file-copy-o",size:{sm:"5x",md:"4x"}}))),a.createElement(f.Z,{"data-track":"CodeBlock|edit_in_codesandbox|".concat(E.pathname),onClick:T},a.createElement(l.Tooltip,{label:"Edit in CodeSandbox"},a.createElement(h,{size:{sm:"5x",md:"4x"}}))),a.createElement(f.Z,{"data-track":"CodeBlock|reset|".concat(E.pathname),onClick:O},a.createElement(l.Tooltip,{label:"Reset the demo"},a.createElement(l.Icon,{icon:"redo",size:{sm:"5x",md:"4x"}})))),a.createElement(l.Fade,{in:v},a.createElement(l.Collapse,{in:v,unmountOnExit:!0},a.createElement(c.uz,{style:C}))))};Demo.displayName="Demo";var E=Demo},34418:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/playground/othello",function(){return t(55272)}])}},function(e){e.O(0,[9774,2888,179],function(){return e(e.s=34418)}),_N_E=e.O()}]);